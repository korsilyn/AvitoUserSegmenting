# AvitoUserSegmenting
Cервис, который хранит пользователя и его сегменты, в которых он состоит.
Дает возможность создания и удаления сегментов, а также добавление и удаление пользователей в сегмент.  
Используемые технологии:  
- Echo (веб фреймворк)
- PosgreSQL (база данных)
- pgx (драйвер для работы с БД)
- Docker + Docker Compose (контейниризация микросервиса)
- migrate (миграции для БД)
- swag (генерация документации)
- logrus (логгер)

## Начнем!
Для подготовки сервиса нужно:
- Склонировать репозиторий:
```
https://github.com/korsilyn/AvitoUserSegmenting
```
- Изменить environment переменные в docker-compose.yaml под себя
- Настроить config/config.yaml

## Запуск
```
make compose-up
```

## Примеры

Некоторые примеры запросов
- [Создание сегмента](#create-seg)
- [Удаление сегмента](#del-seg)
- [Добавление сегментов](#addseg)
- [Удаление сегментов](#removeseg)
- [Получение списка сегментов](#seg-list)

### Создание сегмента <a name="create-seg"></a>

Создание сегмента:
```curl
curl --location --request POST 'http://localhost:8080/api/v1/slugs/create' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "AVITO_SALE_60"
}'
```
Пример ответа:
```json
{
    "id": 1
}
```

### Удаление сегмента <a name="del-seg"></a>

Удаление сегмента по указанному slug:
```curl
curl --location --request DELETE 'http://localhost:8080/api/v1/slugs/remove' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "AVITO_SALE_60"
}'
```
Пример ответа:
```json
{
   "message": "Successful"
}
```

### Добавление сегментов <a name="addseg"></a>

Добавление сегментов пользователя списком без перетирания существующих сегментов с возможностью установить TTL.
```curl
curl --location --request POST 'http://localhost:8080/api/v1/operations/add' \
--header 'Content-Type: application/json' \
--data-raw '{
    "percent": 10,
    "slugs": ["AVITO_SALE_10"],
    "ttl": 10
}'
```
Пример ответа:
```json
{
   "message": "Successful"
}

```

### Удаление сегментов <a name="removeseg"></a>

Удаление сегментов пользователя.
```curl
curl --location --request POST 'http://localhost:8080/api/v1/operations/remove' \
--header 'Content-Type: application/json' \
--data-raw '{
    "slugs": ["AVITO_SALE_10"],
    "user_id": 1,
}'
```
Пример ответа:
```json
{
   "message": "Successful"
}

```

### Получение списка сегментов <a name="seg-list"></a>

Получение списка сегментов пользователя по id:
```curl
curl --location --request GET 'http://localhost:8080/api/v1/operations' \
--header 'Content-Type: application/json' \
--data-raw '{
   "user_id": 1
}'
```
Пример ответа:
```json
{
   "slugs": ["AVITO_SALE_10","AVITO_SALE_30"]
}
```

## Недоработки (почти все мог доделать, было бы чуть больше времени, планирую доделать часть после дедлайна просто для себя)
- Нету тестов вообще
- Не сделана выдача в CSV (1 доп), хоть и были заготовки
- Возможно где-то не очень хороший код, где то можно было сделать получше, поаккуратнее, где то не хватает проверок данных и т.п.
Простой пример - дубликаты убираются не при вносе пользователя, а при выдаче, могло уменьшить запросы к БД.
- Сегменты хранятся по отдельности, в связке пользователь - сегмент 1 ряд. По хорошему так не делать, потому что при тысячах юзеров
запросы будут достаточно долгие. Идея как исправить появилась достаточно поздно.
- При запросе времени из БД выдается UTC, а отправляется MSK+3

## Вопросы
1. Встал вопрос о хранении пользователей без сегментов и в принципе создания БД под юзеров. Подумал и 
решил, что стоит не проверять ID у юзеров, по факту это должна быть информация с внешней БД.
Если у пользователя нет сегментов - просто не храним, иначе храним с временем удаления из сегмента
и при запросе смотрим, чтобы время было актуальным. Заодно удобно будет с выдачей за месяц.  
2. Доп задание 3. "10% пользователей попадают в сегмент". Нет указания на то, откуда брать
id пользователей и общее количество пользователей. Для данного задания решил сделать возможные 
id от 1000 до 1099 (100 юзеров). По хорошему, на проде забирать эти данные с основной БД или 
придумать что нибудь похожее.  
3. В задании написано, что добавление и удаление сегментов должно обрабатываться одним методом, но я посчитал, 
что будет удобнее читать и исправлять код, имея в API методы /add и /remove, чем 1 большой метод /change.  
4. Если пользователю второй раз добавили сегмент, нужно ли обновлять время добавления? 
Я решил не обновлять, потому что такие ситуации мне кажется будут очень редкими.  
5. Доп задание 2. В чем получать TTL и как его хранить? Я решил сразу объединить 2 и 3 
допы, и сразу заносить TTL в поле removed_at. При получении списка пользователей появилась 
доп проверка. TTL передается в часах, просто int цифрой, и потом обрабатывается через 
time.Duration.  
6. Нужна ли авторизация? В задании не указано, но мне кажется, для такого API  нужна либо 
авторизация, либо доступ только из локальной сетки. Тк у меня не осталось времени, 
я оставил этот вопрос просто на грани рассуждений.
